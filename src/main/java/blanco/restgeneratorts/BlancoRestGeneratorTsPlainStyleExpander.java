/*
 * blanco Framework
 * Copyright (C) 2004-2006 IGA Tosiki
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 */
package blanco.restgeneratorts;

import blanco.cg.BlancoCgObjectFactory;
import blanco.cg.BlancoCgSupportedLang;
import blanco.cg.transformer.BlancoCgTransformerFactory;
import blanco.cg.util.BlancoCgSourceUtil;
import blanco.cg.valueobject.BlancoCgField;
import blanco.cg.valueobject.BlancoCgMethod;
import blanco.cg.valueobject.BlancoCgParameter;
import blanco.commons.util.BlancoNameAdjuster;
import blanco.commons.util.BlancoStringUtil;
import blanco.restgeneratorts.valueobject.BlancoRestGeneratorTsTelegramFieldStructure;
import blanco.restgeneratorts.valueobject.BlancoRestGeneratorTsTelegramProcessStructure;
import blanco.restgeneratorts.valueobject.BlancoRestGeneratorTsTelegramStructure;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

/**
 * Generates class source code to process messages from "Message Definition" Excel format.
 *
 * This class is responsible for auto-generating source code from intermediate XML files.
 *
 * @author IGA Tosiki
 * @author tueda
 */
public class BlancoRestGeneratorTsPlainStyleExpander extends  BlancoRestGeneratorTsExpander {
    public void expand(final BlancoRestGeneratorTsTelegramProcessStructure argProcessStructure, final File argDirectoryTarget) {

        // FIrst, generates a telegram.
        Set<String> methodKeys = argProcessStructure.getListTelegrams().keySet(); // It should not be null because it is checked at time of parse.
        for (String methodKey : methodKeys) {
            HashMap<String, BlancoRestGeneratorTsTelegramStructure> kindMap =
                    argProcessStructure.getListTelegrams().get(methodKey);
            Set<String> kindKeys = kindMap.keySet(); // It should not be null because it is checked at time of parse.
            for (String kindKey : kindKeys) {
                generateTelegram(kindMap.get(kindKey), argDirectoryTarget);
            }
            /* Generate Error Telegrams if telegramType is plain. */
            List<BlancoRestGeneratorTsTelegramStructure> errorTelegrams = argProcessStructure.getErrorTelegrams().get(methodKey);
            if (errorTelegrams != null && !errorTelegrams.isEmpty()) {
                for (BlancoRestGeneratorTsTelegramStructure errorTelegram : errorTelegrams) {
                    generateTelegram(errorTelegram, argDirectoryTarget);
                }
            }
        }

        // Next, it generates the telegram processing.
        generateTelegramProcess(argProcessStructure, argDirectoryTarget);
    }

    /**
     * Generates a telegram class.
     *
     * @param argTelegramStructure
     * @param argDirectoryTarget
     */
    private void generateTelegram(
            final BlancoRestGeneratorTsTelegramStructure argTelegramStructure,
            final File argDirectoryTarget) {

        /*
         * The output directory will be in the format specified by the targetStyle argument of the ant task.
         * To maintain compatibility with the previous version, it will be blanco/main if not specified.
         * by tueda, 2019/08/30
         */
        String strTarget = argDirectoryTarget
                .getAbsolutePath(); // advanced
        if (!this.isTargetStyleAdvanced()) {
            strTarget += "/main"; // legacy
        }
        final File fileBlancoMain = new File(strTarget);

        /* tueda DEBUG */
        if (this.isVerbose()) {
            System.out.println("BlancoRestGeneratorTsXml2SourceFile#generateTelegram SATR with argDirectoryTarget : " + argDirectoryTarget.getAbsolutePath());
        }

        fCgFactory = BlancoCgObjectFactory.getInstance();
        fCgSourceFile = fCgFactory.createSourceFile(argTelegramStructure
                .getPackage(), "This source code has been generated by blanco Framework.");
        fCgSourceFile.setEncoding(fEncoding);
        fCgSourceFile.setTabs(this.getTabs());
        // Creates a class.
        fCgClass = fCgFactory.createClass(argTelegramStructure.getName(),
                BlancoStringUtil.null2Blank(argTelegramStructure
                        .getDescription()));
        fCgSourceFile.getClassList().add(fCgClass);
        // The telegram processing class is always public.
        fCgClass.setAccess("public");
        // Inheritance
        if (BlancoStringUtil.null2Blank(argTelegramStructure.getExtends())
                .length() > 0) {
            fCgClass.getExtendClassList().add(
                    fCgFactory.createType(argTelegramStructure.getExtends()));
        }
        // Implementation
        for (int index = 0; index < argTelegramStructure.getImplementsList()
                .size(); index++) {
            final String impl = (String) argTelegramStructure.getImplementsList()
                    .get(index);
            fCgClass.getImplementInterfaceList().add(
                    fCgFactory.createType(impl));
        }
        // Sets the JavaDoc for the class.
        fCgClass.setDescription(argTelegramStructure.getDescription());
        for (String line : argTelegramStructure.getDescriptionList()) {
            fCgClass.getLangDoc().getDescriptionList().add(line);
        }

        /* Sets the annotation for the class. */
        List annotationList = argTelegramStructure.getAnnotationList();
        if (annotationList != null && annotationList.size() > 0) {
            fCgClass.getAnnotationList().addAll(argTelegramStructure.getAnnotationList());
            /* tueda DEBUG */
            if (this.isVerbose()) {
                System.out.println("BlancoRestGeneratorTsXml2SourceFile#generateTelegram : class annotation = " + argTelegramStructure.getAnnotationList().get(0));
            }
        }

        /* In TypeScript, sets the header instead of import. */
        for (int index = 0; index < argTelegramStructure.getHeaderList()
                .size(); index++) {
            final String header = (String) argTelegramStructure.getHeaderList()
                    .get(index);
            fCgSourceFile.getHeaderList().add(header);
        }

        if (this.isVerbose()) {
            System.out.println("BlancoRestGeneratorTsXml2SourceFile: Start create properties : " + argTelegramStructure.getName());
        }

        boolean toJson = false;
        // Telegram definition list.
        for (int indexField = 0; indexField < argTelegramStructure.getListField()
                .size(); indexField++) {
            // Processes each field.
            final BlancoRestGeneratorTsTelegramFieldStructure fieldStructure =
                    argTelegramStructure.getListField().get(indexField);

            // Performs exception processing if a required field is not set.
            if (fieldStructure.getName() == null) {
                throw new IllegalArgumentException(fBundle
                        .getXml2sourceFileErr004(argTelegramStructure.getName()));
            }
            if (fieldStructure.getType() == null) {
                throw new IllegalArgumentException(fBundle.getXml2sourceFileErr003(
                        argTelegramStructure.getName(), fieldStructure.getName()));
            }

            if (!toJson && !fieldStructure.getExcludeToJson()) {
                toJson = true;
            }

            if (this.isVerbose()) {
                System.out.println("property : " + fieldStructure.getName());
            }

            // Creates fields.
            buildField(argTelegramStructure, fieldStructure);

            // Creates a setter method.
            buildMethodSet(fieldStructure);

            // Creates a getter method.
            buildMethodGet(fieldStructure);

            // Creates a method that returns a Type string.
            buildMethodType(fieldStructure);

            // Creates a method that returns a Generic string.
            buildMethodGeneric(fieldStructure);

            // validation will be implemented later.
        }

        buildMethodTelegramId(argTelegramStructure);
        buildMethodTelegramType(argTelegramStructure);
        buildMethodTelegramMethod(argTelegramStructure);
        buildMethodAdditionalPath(argTelegramStructure);

        if (BlancoRestGeneratorTsConstants.TELEGRAM_TYPE_INPUT.equalsIgnoreCase(argTelegramStructure.getTelegramType())) {
            buildMethodGetPathParams(argTelegramStructure);
            buildMethodGetQueryParams(argTelegramStructure);
            if (BlancoRestGeneratorTsConstants.TELEGRAM_METHOD_POST.equalsIgnoreCase(argTelegramStructure.getTelegramMethod()) ||
            BlancoRestGeneratorTsConstants.TELEGRAM_METHOD_PUT.equalsIgnoreCase(argTelegramStructure.getTelegramMethod())) {
                buildMethodGetBodyParams(argTelegramStructure);
            }
        }

        if (toJson && this.isDefaultGenerateToJson()) {
            buildMethodToJSON(argTelegramStructure);
        }

        // Auto-generates the actual source code based on the collected information.
        BlancoCgTransformerFactory.getTsSourceTransformer().transform(
                fCgSourceFile, fileBlancoMain);
    }


    /**
     * Generates toJSON method.
     *
     * @param argTelegramStructure
     */
    private void buildMethodToJSON(
            final BlancoRestGeneratorTsTelegramStructure  argTelegramStructure
    ) {
        final BlancoCgMethod method = fCgFactory.createMethod("toJSON",
                "Gets the properties to be written to JSON from this telegram.");
        fCgClass.getMethodList().add(method);

        method.setReturn(fCgFactory.createReturn("any",
                "An object returned by toJSON"));
        method.setNotnull(true);
        /*
         * Specified, but not valid in TypeScript.
         */
        method.setFinal(true);

        final List<String> listLine = method.getLineList();

        listLine.add("return {");

        String line = "";
        for (int indexField = 0; indexField < argTelegramStructure.getListField()
                .size(); indexField++) {
            final BlancoRestGeneratorTsTelegramFieldStructure field =
                    argTelegramStructure.getListField().get(indexField);

            if (!field.getExcludeToJson()) {
                if (indexField > 0 && line.length() > 0) {
                    listLine.add(line + ",");
                }
                String alias = field.getName();
                if (field.getAlias() != null && field.getAlias().trim().length() > 0) {
                    alias = field.getAlias();
                }
                line = alias + ": this." + field.getName();
            }
        }
        if (line.length() > 0) {
            listLine.add(line);
        }
        listLine.add("};");
    }

    /**
     * Build method for path parameters.
     * @param argTelegramStructure
     */
    private void buildMethodGetPathParams(
            final BlancoRestGeneratorTsTelegramStructure  argTelegramStructure
    ) {
        final BlancoCgMethod method = fCgFactory.createMethod("getPathParams",
                "Get the path parameters from this telegram.");
        fCgClass.getMethodList().add(method);

        method.setReturn(fCgFactory.createReturn("string | undefined",
                "A string returned by getPathParams"));
        method.setNotnull(true);
        /*
         * Specified, but not valid in TypeScript.
         */
        method.setFinal(true);

        /* additional path */
        String additionalPath = argTelegramStructure.getAdditionalPath();
        String pathParams = "";
        if (additionalPath != null && additionalPath.trim().length() > 0) {
            pathParams += additionalPath;
        }

        for (BlancoRestGeneratorTsTelegramFieldStructure fieldStructure : argTelegramStructure.getListField()) {
            if (BlancoRestGeneratorTsConstants.TELEGRAM_QUERY_KIND_PATH.equalsIgnoreCase(fieldStructure.getQueryKind())) {
                String alias = fieldStructure.getName();
                if (fieldStructure.getAlias() != null && fieldStructure.getAlias().trim().length() > 0) {
                    alias = fieldStructure.getAlias();
                }
                pathParams += "/";
                pathParams += alias;
            }
        }

        final List<String> listLine = method.getLineList();
        if (pathParams.length() == 0) {
            listLine.add("return undefined;");
        } else {
            listLine.add("return \"" + pathParams + "\";");
        }
    }

    /**
     * Build method for query parameters
     * @param argTelegramStructure
     */
    private void buildMethodGetQueryParams(
            final BlancoRestGeneratorTsTelegramStructure  argTelegramStructure
    ) {
        final BlancoCgMethod method = fCgFactory.createMethod("getQueryParams",
                "Get the query parameters from this telegram.");
        fCgClass.getMethodList().add(method);

        method.setReturn(fCgFactory.createReturn("any",
                "A string returned by getQueryParams"));
        method.setNotnull(true);
        /*
         * Specified, but not valid in TypeScript.
         */
        method.setFinal(true);

        String telegramMethod = argTelegramStructure.getTelegramMethod();
        boolean isGetDelete = BlancoRestGeneratorTsConstants.TELEGRAM_METHOD_GET.equalsIgnoreCase(telegramMethod) || BlancoRestGeneratorTsConstants.TELEGRAM_METHOD_DELETE.equalsIgnoreCase(telegramMethod);

        final List<String> listLine = new ArrayList<>();
        listLine.add("return {");
        String line = "";
        boolean isFirst = true;
        for (BlancoRestGeneratorTsTelegramFieldStructure fieldStructure :
         argTelegramStructure.getListField()) {
            String queryKind = fieldStructure.getQueryKind();
            /*
             * Add to query params if queryKind is not PATH,
             * always on Get or Delete,
             * specified Query on Post or Put.
             */
            if (!BlancoRestGeneratorTsConstants.TELEGRAM_QUERY_KIND_PATH.equalsIgnoreCase(queryKind) &&
                    (isGetDelete || BlancoRestGeneratorTsConstants.TELEGRAM_QUERY_KIND_QUERY.equalsIgnoreCase(queryKind))) {
                if (!isFirst) {
                    listLine.add(line + ",");
                }
                isFirst = false;
                String alias = fieldStructure.getName();
                if (fieldStructure.getAlias() != null && fieldStructure.getAlias().trim().length() > 0) {
                    alias = fieldStructure.getAlias();
                }
                line = alias + ": this." + fieldStructure.getName();
            }
        }
        if (line.length() > 0) {
            listLine.add(line);
        }
        listLine.add("};");
        if (isFirst) {
            method.getLineList().add("return undefined;");
        } else {
            method.getLineList().addAll(listLine);
        }
    }

    /**
     * Build method for body parameters
     * @param argTelegramStructure
     */
    private void buildMethodGetBodyParams(
            final BlancoRestGeneratorTsTelegramStructure  argTelegramStructure
    ) {
        final BlancoCgMethod method = fCgFactory.createMethod("getBodyParams",
                "Get the body parameters from this telegram.");
        fCgClass.getMethodList().add(method);

        method.setReturn(fCgFactory.createReturn("any",
                "A string returned by getBodyParams"));
        method.setNotnull(true);
        /*
         * Specified, but not valid in TypeScript.
         */
        method.setFinal(true);

        final List<String> listLine = new ArrayList<>();
        listLine.add("return {");

        String line = "";
        boolean isFirst = true;
        for (BlancoRestGeneratorTsTelegramFieldStructure fieldStructure :
                argTelegramStructure.getListField()) {
            String queryKind = fieldStructure.getQueryKind();
            if (!BlancoRestGeneratorTsConstants.TELEGRAM_QUERY_KIND_PATH.equalsIgnoreCase(queryKind) &&
                    !BlancoRestGeneratorTsConstants.TELEGRAM_QUERY_KIND_QUERY.equalsIgnoreCase(queryKind)) {
                if (!isFirst) {
                    listLine.add(line + ",");
                }
                isFirst = false;
                String alias = fieldStructure.getName();
                if (fieldStructure.getAlias() != null && fieldStructure.getAlias().trim().length() > 0) {
                    alias = fieldStructure.getAlias();
                }
                line = alias + ": this." + fieldStructure.getName();
            }
        }
        if (line.length() > 0) {
            listLine.add(line);
        }
        listLine.add("};");
        if (isFirst) {
            method.getLineList().add("return undefined;");
        } else {
            method.getLineList().addAll(listLine);
        }
    }

    /**
     *
     * @param argTelegramStructure
     */
    private void buildMethodAdditionalPath(
            final BlancoRestGeneratorTsTelegramStructure  argTelegramStructure
    ) {
        // Creates an additionalPath.
        String additionalPath = argTelegramStructure.getAdditionalPath();
        if (BlancoStringUtil.null2Blank(additionalPath).trim().length() == 0) {
            additionalPath = null;
        }

        final String fieldName = "_additionalPath";
        final BlancoCgField field = fCgFactory.createField(fieldName,
                "string | undefined", null);

        fCgClass.getFieldList().add(field);
        field.setAccess("private");
        field.setNotnull(true);
        field.getLangDoc().getDescriptionList().add(
                BlancoCgSourceUtil.escapeStringAsLangDoc(BlancoCgSupportedLang.TS, fBundle.getXml2sourceFileFieldDefault(
                        additionalPath)));
        if (additionalPath != null) {
            field.setDefault("\"" + additionalPath +"\"");
        } else {
            field.setDefault("undefined");
        }

        // Generates a setter method.
        final BlancoCgMethod setterMethod = fCgFactory.createMethod(BlancoNameAdjuster.toParameterName(fieldName),
                fBundle.getXml2sourceFileSetLangdoc01(fieldName));
        fCgClass.getMethodList().add(setterMethod);

        setterMethod.setAccess("set");

        // JavaDoc configuration of the setter method.
        setterMethod.getLangDoc().getDescriptionList().add(
                fBundle.getXml2sourceFileSetLangdoc02("string | undefined"));

        // param configuration of the setter method.
        BlancoCgParameter param = fCgFactory.createParameter("arg"
                        + BlancoNameAdjuster.toClassName(fieldName),
                "string | undefined",
                fBundle.getXml2sourceFileSetArgLangdoc(fieldName));
        param.setNotnull(true);

        setterMethod.getParameterList().add(param);

        // Implements the setter method.
        setterMethod.getLineList().add("this." + fieldName + " = "
                + "arg" + BlancoNameAdjuster.toClassName(fieldName) + ";");

        // Generates a getter method.
        final BlancoCgMethod getterMethod = fCgFactory.createMethod(BlancoNameAdjuster.toParameterName(fieldName),
                fBundle.getXml2sourceFileGetLangdoc01(fieldName));
        fCgClass.getMethodList().add(getterMethod);

        getterMethod.setAccess("get");

        // JavaDoc configuration of the getter method.
        getterMethod.getLangDoc().getDescriptionList().add(
                fBundle.getXml2sourceFileGetLangdoc02("string|undefined"));

        // Return value configuration of the getter method.
        getterMethod.setNotnull(true);
        getterMethod.setReturn(fCgFactory.createReturn("string | undefined",
                fBundle.getXml2sourceFileGetReturnLangdoc(fieldName)));

        // Implements the getter method.
        getterMethod.getLineList().add("return this." + fieldName + ";");
    }
}
